#include "GDIPlusTexture.h"

GDIPlusTexture::GDIPlusTexture( IDirect3DDevice9 *gpu, int width, int height, bool smoothingMode )
{
  this->gpu = gpu ;
  this->width = width ;
  this->height = height ;

  // create a texture
  HRESULT hr ;

  hr = D3DXCreateTexture( gpu,
    width, height,
    1, 0,
    D3DFMT_X8R8G8B8, D3DPOOL_MANAGED, &tex ) ;
  DX_CHECK( hr, "Create texture for GDI+ usage" ) ;
  
  // Get its surface
  hr = tex->GetSurfaceLevel( 0, &surface ) ;
  DX_CHECK( hr, "Get surface of GDI+ texture" ) ;

  hr = surface->GetDC( &texDC ) ;
  DX_CHECK( hr, "GetDC of GDI+ texture" ) ;

  
  // Create the GDI+ graphics object
  // connected to the texture via its DC now
  g = new Graphics( texDC ) ;

  if( !g )
  {
    printWindowsLastError( "Could not get g, GDI+ texture" ) ;
  }

  if( smoothingMode )
  {
    g->SetSmoothingMode( SmoothingModeAntiAlias ) ;
    g->SetTextRenderingHint( TextRenderingHintAntiAlias ) ;
  }

}

IDirect3DTexture9* GDIPlusTexture::getTexture()
{
  // K now i'm going to hack a copy
  // of the texture because it doesn't let you use
  // A8R8G8B8 when you use a DC.  For some silly reason.
  // Luckily the X8 DOES preserve the alpha channel values
  // generated by GDI+
  D3DLOCKED_RECT lockedRectTex, lockedRectCpyA8 ;

  // copy texture with A8
  IDirect3DTexture9 *cpyA8 ;

  DX_CHECK( D3DXCreateTexture(
    gpu, width, height,
    1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
    &cpyA8 ), "Create texture from file in memory" ) ;
  


  int dataLen = width*height*sizeof(int) ; // a8r8g8b8!

  // To lock, you have to release the DC first.
  DX_CHECK( surface->ReleaseDC( texDC ), "Release DC, before lock tex" ) ;

  // lock both
  DX_CHECK( tex->LockRect( 0, &lockedRectTex, NULL, 0 ), "Lock rect tex" ) ;
  DX_CHECK( cpyA8->LockRect( 0, &lockedRectCpyA8, NULL, 0 ), "Lock rect cpyA8" ) ;

  memcpy( lockedRectCpyA8.pBits, lockedRectTex.pBits, dataLen ) ;

  DX_CHECK( cpyA8->UnlockRect( 0 ), "Unlock rect cpyA8" ) ;
  DX_CHECK( tex->UnlockRect( 0 ), "Unlock rect tex" ) ;

  // can get the DC back now
  DX_CHECK( surface->GetDC( &texDC ), "re-gain DC" ) ;

  return cpyA8 ;
}

int GDIPlusTexture::getWidth()
{
  return width ;
}
int GDIPlusTexture::getHeight()
{
  return height ;
}

void GDIPlusTexture::boxedText( TCHAR* text, Font *font, RECT padding, Color textColor, Color bkgColor, StringAlignment alignment )
{

  SolidBrush bkgBrush( bkgColor ) ;
  SolidBrush textBrush( textColor ) ;

  StringFormat sf ;
  sf.SetAlignment( alignment ) ;

  if( font->GetUnit() != UnitPixel )
  {
    warning( "GDIPlusTexture::boxedText:  "
      "font's units weren't in pixels.  "
      "Changing it to pixels for you.." ) ;
  }

  // MUST BE IN PIXELS else sizing doesn't work
  LOGFONTA logFont ;
  font->GetLogFontA( g, &logFont ) ;
  
  // We're going to have to re-create a font
  // that has same properties only in pixels units
  // We'll do this everytime anyway, no harm done
  // if person used correct units.
  FontFamily fontFamily( TEXT("Arial" ) ) ;
  font->GetFamily( &fontFamily ) ;

  Font *newFont = new Font( &fontFamily,
    font->GetSize(), font->GetStyle(),
    UnitPixel ) ;

  font = newFont ;
   
  // retrieve the limiting rect by computing size
  // only ID3DXFont:: knows how to DT_CALCRECT though.

  // create an identical d3dfont to compute the rectangle
  ID3DXFont *d3dFont ;
  DX_CHECK( D3DXCreateFontA( gpu, 12.0f, 0, FW_BOLD, 1, FALSE, DEFAULT_CHARSET,
    OUT_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
    "Arial", &d3dFont ), "Create d3d font" ) ;

  RECT d3dComputedRect = {0, 0, 1, 1} ;
  int height = d3dFont->DrawTextW(
    NULL, text, -1,
    &d3dComputedRect,
    DT_CALCRECT, 0 ) ;

  info( "computed rect %d %d %d %d, height %d",
    d3dComputedRect.left, d3dComputedRect.top,
    d3dComputedRect.bottom, d3dComputedRect.right, height ) ;


  RectF limitingRect(
    d3dComputedRect.left,
    d3dComputedRect.top,
    d3dComputedRect.right - d3dComputedRect.left,
    (d3dComputedRect.bottom - d3dComputedRect.top) + height ) ;

  RectF fillRectBounds(
    limitingRect.X,
    limitingRect.Y,
    limitingRect.Width + padding.left + padding.right,
    limitingRect.Height + padding.top + padding.bottom ) ;
  g->FillRectangle( &bkgBrush, fillRectBounds ) ;

  RectF stringRectBounds(
    limitingRect.X,
    limitingRect.Y + padding.top,
    limitingRect.Width + padding.left + padding.right,
    limitingRect.Height + padding.top
  ) ;
  
  g->DrawString( text, -1, font, stringRectBounds, &sf, &textBrush ) ;
 
  

  SAFE_RELEASE( d3dFont ) ;
  delete newFont ;
  
}

void GDIPlusTexture::boxedText( TCHAR* text, Font *font, RECT padding, Color textColor, Color bkgColor, RectF limitingRect, StringAlignment alignment ) 
{
  SolidBrush bkgBrush( bkgColor ) ;
  SolidBrush textBrush( textColor ) ;

  // draw the bkg rect
  g->FillRectangle( &bkgBrush, limitingRect ) ;

  StringFormat sf ;
  sf.SetAlignment( alignment ) ;

  g->DrawString( text, 1, font, limitingRect, &sf, &textBrush ) ;
}

GDIPlusTexture::~GDIPlusTexture()
{
  // The user will draw with g onto
  // the surface presumably until this
  // GDIPlusTexture object is destroyed.
  // Then the texture need live on, but
  // the surfaceDC can be released
  surface->ReleaseDC( texDC ) ;

  // the TEX was connected to the
  // backDC, and its safe to release it
  SAFE_RELEASE( tex ) ;
}


IDirect3DTexture9*
GDIPlusTexture::D3DXCreateTextureFromFileViaGDIPlus(
  IDirect3DDevice9 *gpu, TCHAR *filename
)
{
  puts( "OK" ) ;

  return NULL ;
}

